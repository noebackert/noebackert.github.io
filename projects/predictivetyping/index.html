<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Predictive typing software in C | Noé Backert | Blog</title><meta name=keywords content="C,Programming"><meta name=description content="Implementation of a predictive typing program in C using hash tables and trie data structures to suggest next words in real time based on word frequency and user input."><meta name=author content="Noé Backert, Antoine Banchet"><link rel=canonical href=https://www.noe.backert.fr/projects/predictivetyping/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://www.noe.backert.fr/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.noe.backert.fr/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.noe.backert.fr/favicon-32x32.png><link rel=apple-touch-icon href=https://www.noe.backert.fr/apple-touch-icon.png><link rel=mask-icon href=https://www.noe.backert.fr/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.noe.backert.fr/projects/predictivetyping/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/custom.css><meta property="og:url" content="https://www.noe.backert.fr/projects/predictivetyping/"><meta property="og:site_name" content="Noé Backert | Blog"><meta property="og:title" content="Predictive typing software in C"><meta property="og:description" content="Implementation of a predictive typing program in C using hash tables and trie data structures to suggest next words in real time based on word frequency and user input."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="projects"><meta property="article:published_time" content="2023-04-01T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-01T00:00:00+00:00"><meta property="article:tag" content="C"><meta property="article:tag" content="Programming"><meta name=twitter:card content="summary"><meta name=twitter:title content="Predictive typing software in C"><meta name=twitter:description content="Implementation of a predictive typing program in C using hash tables and trie data structures to suggest next words in real time based on word frequency and user input."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://www.noe.backert.fr/projects/"},{"@type":"ListItem","position":2,"name":"Predictive typing software in C","item":"https://www.noe.backert.fr/projects/predictivetyping/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Predictive typing software in C","name":"Predictive typing software in C","description":"Implementation of a predictive typing program in C using hash tables and trie data structures to suggest next words in real time based on word frequency and user input.","keywords":["C","Programming"],"articleBody":"Hash based predictive algorithm for typing Project Details Project Type: Programmation in C Tools: C, git Duration: 2 weeks Team: Duo project with Antoine Banchet Introduction The goal of this project is to develop a predictive typing software in C. The software will predict the next word based on the first characters typed by the user. The software will use a hash table to store the words and their frequency in a text file. The software will be able to predict the next word based on the frequency of the words in the text file.\nProject Overview The project involves:\nDeveloping in C\nUsing a hash table to store the words and their frequency in a file\nPredicting the next word based on the frequency of the words in the text file in real time\nGeneral Description of the Project The project focuses on developing a predictive text algorithm using a trie data structure. This trie has nodes with 27 children: 26 for each letter of the alphabet and one for special characters, represented by the symbol #. The algorithm works by traversing the trie from the root, following the letters of the input word sequentially. Nodes with a weight of 0 indicate that the traversal has not reached the end of a word, while nodes with a positive weight denote the end of a word and its significance. This structure enables the predictive text algorithm to suggest relevant words to users in real-time based on their input.\nLibraries // hash.h void initializeHashTable(HashTable *hashTab); // Initializes an empty hash table void loadDictionaryFromFile(HashTable* hashTab, const char* dictionaryFileName); // Loads a dictionary from a file and adds it to the hash table void insertElementToHashTable(HashTable* hashTab, char* word); // Inserts an element into the hash table bool checkExistenceWordInDictionary(HashTable* hashTab, char * word); // Checks if a word exists in the hash table unsigned long getHashValue(char *string); // Computes the hash value of a string The library hash.h implements a hash table for storing and searching words in nearly constant time. It uses a linked list to handle collisions.\n// trie.h void initialize_trie(Trie *root); // Initializes an empty prefix tree (trie) void add_word(Trie *root, char *word); // Adds a word to the prefix tree (trie) void create_trie(Trie *trie, char *fileName); // Loads a dictionary from a file and stores it in a prefix tree (trie) void print_trie(Trienode* node, char* str, int level); // Prints the prefix tree (trie) void print_trie_graph(Trienode* node, int level, FILE *file); // Prints the prefix tree (trie) in graphical form List suggest_words(Trie* trie, char* prefix); // Suggests words starting with a given prefix and returns a linked list of suggested words void serialize_trie(Trienode *root, FILE *file); // Serializes a Trie tree by writing its nodes into a binary file Trienode* deserialize_trie(FILE *file); // Deserializes a Trie tree from a binary file and returns a pointer to its root void save_trie(Trie *trie); // Saves a trie structure into a binary file using serialize_trie() void load_trie(Trie *trie); // Loads a prefix tree (trie) from a binary file The library trie.h implements a prefix tree (trie) for storing and searching words. Tries are also known as prefix trees.\ntypedef struct trienode { char letter; int weight; struct trienode *child[27]; } Trienode; typedef struct trie { Trienode *root; } Trie; The trie structure enables a predictive text algorithm. Each node in this tree contains 27 children: 26 for each letter of the alphabet and the 27th for managing special characters, represented by the symbol #.\nThe algorithm operates by traversing the trie from the root, following each letter of the input word one by one. If a node has a weight of 0, it indicates that it’s not the end of a word. Conversely, if the node’s weight is greater than 0, it signifies the end of a word and its importance.\nThis trie structure allows the predictive text algorithm to suggest relevant words to the user in real-time, based on the letters they input.\nDescription of necessary functions // Function create_node Trienode *create_node(char letter) { Trienode *newnode = (Trienode*) malloc(sizeof(Trienode)); for (int i = 0; i \u003c 27; i++) { newnode-\u003echild[i] = NULL; } newnode-\u003eletter = letter; newnode-\u003eweight = 0; return newnode; } This function create_node creates a new node in a trie tree. It takes a character “letter” as input, which will be stored in the newly created node. The function initializes all children to NULL and sets the weight to 0.\n// Function add_word void add_word(Trie *trie, char *word) { Trienode* current = trie-\u003eroot; while((*word) != '\\0') { int index = *word - 'a'; // ASCII difference if ((*word) \u003c 97 || (*word) \u003e 122) { index = 27; *word = '#'; } if (current-\u003echild[index] == NULL) { current-\u003echild[index] = create_node(*word); } current = current-\u003echild[index]; word++; } current-\u003eweight++; } The add_word function traverses the word character by character and creates nodes for each letter of the word. If a node for that letter does not yet exist, it is created and placed in the “child” array of the current node. The “weight” field of the last created node is then incremented to indicate that this node marks the end of a word and to assign its weight.\n// Function create_trie void create_trie(Trie *trie, char *fileName) { FILE *file; file = fopen(fileName, \"r\"); if (file != NULL) { char word[MAX_WORD_LENGHT]; while (fscanf(file, \"%s\", word) \u003e= 1) { add_word(trie, word); } } else { printf(\"Le fichier n'a pas été trouvé.\"); } fclose(file); } This function reads a text file and adds each word to the trie.\n// Function suggest_words List suggest_words(Trie* trie, char* prefix) { List liste_mots; initializeList(\u0026liste_mots); Trienode* current = trie-\u003eroot; char prefix_copy[strlen(prefix)]; strcpy(prefix_copy, prefix); prefix_copy[strlen(prefix) - 1] = '\\0'; while ((*prefix) != '\\0') { int index = *prefix - 'a'; if ((*prefix) \u003c 97 || (*prefix) \u003e 122) { index = 27; } if (current-\u003echild[index] == NULL) { printf(\"Le préfixe n'existe pas dans le dictionnaire.\\n\"); return liste_mots; } current = current-\u003echild[index]; prefix++; } char buffer[100]; search_prefix(current, prefix_copy, buffer, 0, \u0026liste_mots); triFusion(\u0026liste_mots); return liste_mots; } The suggest_words function is central to the program. It takes a prefix and a trie tree containing words as inputs. It searches for all words in the dictionary that start with this prefix by traversing the trie tree from the root to the last node corresponding to the prefix’s last letter. Then, it uses a search function to find all words following this prefix and stores them in a linked list, which it sorts before returning.\n// Functions for saving/loading trie void serialize_trie(Trienode *root, FILE *file); Trienode* deserialize_trie(FILE *file); void save_trie(Trie *trie); void load_trie(Trie *trie); These functions allow saving and loading the trie structure from a binary file.\nConclusion In conclusion, the predictive typing software developed in C is a powerful tool that can predict the next word based on the frequency of words in a text file. The software uses a hash table to store the words and their frequency and a trie data structure to predict the next word based on the user’s input. The software is efficient and can predict the next word in real time.\nHowever, today these types of software are not used anymore because of the power of modern computers and the use of machine learning.\n","wordCount":"1205","inLanguage":"en","datePublished":"2023-04-01T00:00:00Z","dateModified":"2023-04-01T00:00:00Z","author":{"@type":"Person","name":"Noé Backert, Antoine Banchet"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.noe.backert.fr/projects/predictivetyping/"},"publisher":{"@type":"Organization","name":"Noé Backert | Blog","logo":{"@type":"ImageObject","url":"https://www.noe.backert.fr/img/favicon.ico"}}}</script><script>window.MathJax={tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["$$","$$"],["\\[","\\]"]]},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]}}</script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js async></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.noe.backert.fr/ accesskey=h title="Noé Backert | Blog (Alt + H)">Noé Backert | Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.noe.backert.fr/ title=Home><span>Home</span></a></li><li><a href=https://www.noe.backert.fr/resume/ title=Resume><span>Resume</span></a></li><li><a href=https://www.noe.backert.fr/ctf/ title="CTF Writeups"><span>CTF Writeups</span></a></li><li><a href=https://www.noe.backert.fr/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://www.noe.backert.fr/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.noe.backert.fr/>Home</a>&nbsp;»&nbsp;<a href=https://www.noe.backert.fr/projects/>Projects</a></div><h1 class="post-title entry-hint-parent">Predictive typing software in C</h1><div class=post-description>Implementation of a predictive typing program in C using hash tables and trie data structures to suggest next words in real time based on word frequency and user input.</div><div class=post-meta><span title='2023-04-01 00:00:00 +0000 UTC'>April 1, 2023</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Noé Backert, Antoine Banchet</div></header><div class=post-content><h3 id=hash-based-predictive-algorithm-for-typing>Hash based predictive algorithm for typing<a hidden class=anchor aria-hidden=true href=#hash-based-predictive-algorithm-for-typing>#</a></h3><h2 id=project-details>Project Details<a hidden class=anchor aria-hidden=true href=#project-details>#</a></h2><ul><li><strong>Project Type</strong>: Programmation in C</li><li><strong>Tools</strong>: C, git</li><li><strong>Duration</strong>: 2 weeks</li><li><strong>Team</strong>: Duo project with Antoine Banchet</li></ul><hr><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>The goal of this project is to develop a predictive typing software in C. The software will predict the next word based on the first characters typed by the user. The software will use a hash table to store the words and their frequency in a text file. The software will be able to predict the next word based on the frequency of the words in the text file.</p><hr><h2 id=project-overview>Project Overview<a hidden class=anchor aria-hidden=true href=#project-overview>#</a></h2><p>The project involves:</p><ul><li><p>Developing in C</p></li><li><p>Using a hash table to store the words and their frequency in a file</p></li><li><p>Predicting the next word based on the frequency of the words in the text file in real time</p></li></ul><hr><h3 id=general-description-of-the-project>General Description of the Project<a hidden class=anchor aria-hidden=true href=#general-description-of-the-project>#</a></h3><p>The project focuses on developing a predictive text algorithm using a trie data structure. This trie has nodes with 27 children: 26 for each letter of the alphabet and one for special characters, represented by the symbol #. The algorithm works by traversing the trie from the root, following the letters of the input word sequentially. Nodes with a weight of 0 indicate that the traversal has not reached the end of a word, while nodes with a positive weight denote the end of a word and its significance. This structure enables the predictive text algorithm to suggest relevant words to users in real-time based on their input.</p><hr><h2 id=libraries>Libraries<a hidden class=anchor aria-hidden=true href=#libraries>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// hash.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initializeHashTable</span>(HashTable <span style=color:#f92672>*</span>hashTab);
</span></span><span style=display:flex><span><span style=color:#75715e>// Initializes an empty hash table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>loadDictionaryFromFile</span>(HashTable<span style=color:#f92672>*</span> hashTab, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> dictionaryFileName);
</span></span><span style=display:flex><span><span style=color:#75715e>// Loads a dictionary from a file and adds it to the hash table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insertElementToHashTable</span>(HashTable<span style=color:#f92672>*</span> hashTab, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> word);
</span></span><span style=display:flex><span><span style=color:#75715e>// Inserts an element into the hash table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>checkExistenceWordInDictionary</span>(HashTable<span style=color:#f92672>*</span> hashTab, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> word);
</span></span><span style=display:flex><span><span style=color:#75715e>// Checks if a word exists in the hash table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>getHashValue</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>string);
</span></span><span style=display:flex><span><span style=color:#75715e>// Computes the hash value of a string
</span></span></span></code></pre></div><p>The library hash.h implements a hash table for storing and searching words in nearly constant time. It uses a linked list to handle collisions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// trie.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initialize_trie</span>(Trie <span style=color:#f92672>*</span>root);
</span></span><span style=display:flex><span><span style=color:#75715e>// Initializes an empty prefix tree (trie)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add_word</span>(Trie <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>word);
</span></span><span style=display:flex><span><span style=color:#75715e>// Adds a word to the prefix tree (trie)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>create_trie</span>(Trie <span style=color:#f92672>*</span>trie, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>fileName);
</span></span><span style=display:flex><span><span style=color:#75715e>// Loads a dictionary from a file and stores it in a prefix tree (trie)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_trie</span>(Trienode<span style=color:#f92672>*</span> node, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> str, <span style=color:#66d9ef>int</span> level);
</span></span><span style=display:flex><span><span style=color:#75715e>// Prints the prefix tree (trie)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_trie_graph</span>(Trienode<span style=color:#f92672>*</span> node, <span style=color:#66d9ef>int</span> level, FILE <span style=color:#f92672>*</span>file);
</span></span><span style=display:flex><span><span style=color:#75715e>// Prints the prefix tree (trie) in graphical form
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>List <span style=color:#a6e22e>suggest_words</span>(Trie<span style=color:#f92672>*</span> trie, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> prefix);
</span></span><span style=display:flex><span><span style=color:#75715e>// Suggests words starting with a given prefix and returns a linked list of suggested words
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>serialize_trie</span>(Trienode <span style=color:#f92672>*</span>root, FILE <span style=color:#f92672>*</span>file);
</span></span><span style=display:flex><span><span style=color:#75715e>// Serializes a Trie tree by writing its nodes into a binary file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>Trienode<span style=color:#f92672>*</span> <span style=color:#a6e22e>deserialize_trie</span>(FILE <span style=color:#f92672>*</span>file);
</span></span><span style=display:flex><span><span style=color:#75715e>// Deserializes a Trie tree from a binary file and returns a pointer to its root
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>save_trie</span>(Trie <span style=color:#f92672>*</span>trie);
</span></span><span style=display:flex><span><span style=color:#75715e>// Saves a trie structure into a binary file using serialize_trie()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>load_trie</span>(Trie <span style=color:#f92672>*</span>trie);
</span></span><span style=display:flex><span><span style=color:#75715e>// Loads a prefix tree (trie) from a binary file
</span></span></span></code></pre></div><p>The library trie.h implements a prefix tree (trie) for storing and searching words. Tries are also known as prefix trees.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> trienode
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> letter;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> weight;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> trienode <span style=color:#f92672>*</span>child[<span style=color:#ae81ff>27</span>];
</span></span><span style=display:flex><span>} Trienode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> trie
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Trienode <span style=color:#f92672>*</span>root;
</span></span><span style=display:flex><span>} Trie;
</span></span></code></pre></div><p>The trie structure enables a predictive text algorithm. Each node in this tree contains 27 children: 26 for each letter of the alphabet and the 27th for managing special characters, represented by the symbol #.</p><p>The algorithm operates by traversing the trie from the root, following each letter of the input word one by one. If a node has a weight of 0, it indicates that it&rsquo;s not the end of a word. Conversely, if the node&rsquo;s weight is greater than 0, it signifies the end of a word and its importance.</p><p>This trie structure allows the predictive text algorithm to suggest relevant words to the user in real-time, based on the letters they input.</p><h3 id=description-of-necessary-functions>Description of necessary functions<a hidden class=anchor aria-hidden=true href=#description-of-necessary-functions>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Function create_node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Trienode <span style=color:#f92672>*</span><span style=color:#a6e22e>create_node</span>(<span style=color:#66d9ef>char</span> letter)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Trienode <span style=color:#f92672>*</span>newnode <span style=color:#f92672>=</span> (Trienode<span style=color:#f92672>*</span>) <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(Trienode));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>27</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        newnode<span style=color:#f92672>-&gt;</span>child[i] <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    newnode<span style=color:#f92672>-&gt;</span>letter <span style=color:#f92672>=</span> letter;
</span></span><span style=display:flex><span>    newnode<span style=color:#f92672>-&gt;</span>weight <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> newnode;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function create_node creates a new node in a trie tree. It takes a character &ldquo;letter&rdquo; as input, which will be stored in the newly created node. The function initializes all children to NULL and sets the weight to 0.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Function add_word
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add_word</span>(Trie <span style=color:#f92672>*</span>trie, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>word)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Trienode<span style=color:#f92672>*</span> current <span style=color:#f92672>=</span> trie<span style=color:#f92672>-&gt;</span>root;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>((<span style=color:#f92672>*</span>word) <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\0&#39;</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>word <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>; <span style=color:#75715e>// ASCII difference
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> ((<span style=color:#f92672>*</span>word) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>97</span> <span style=color:#f92672>||</span> (<span style=color:#f92672>*</span>word) <span style=color:#f92672>&gt;</span>  <span style=color:#ae81ff>122</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            index <span style=color:#f92672>=</span> <span style=color:#ae81ff>27</span>;
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>word <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;#&#39;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (current<span style=color:#f92672>-&gt;</span>child[index] <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            current<span style=color:#f92672>-&gt;</span>child[index] <span style=color:#f92672>=</span> <span style=color:#a6e22e>create_node</span>(<span style=color:#f92672>*</span>word);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>child[index];  
</span></span><span style=display:flex><span>        word<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    current<span style=color:#f92672>-&gt;</span>weight<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The add_word function traverses the word character by character and creates nodes for each letter of the word. If a node for that letter does not yet exist, it is created and placed in the &ldquo;child&rdquo; array of the current node. The &ldquo;weight&rdquo; field of the last created node is then incremented to indicate that this node marks the end of a word and to assign its weight.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Function create_trie
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>create_trie</span>(Trie <span style=color:#f92672>*</span>trie, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>fileName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    FILE <span style=color:#f92672>*</span>file;
</span></span><span style=display:flex><span>    file <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(fileName, <span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (file <span style=color:#f92672>!=</span> NULL)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> word[MAX_WORD_LENGHT];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>fscanf</span>(file, <span style=color:#e6db74>&#34;%s&#34;</span>, word) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>add_word</span>(trie, word);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Le fichier n&#39;a pas été trouvé.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fclose</span>(file);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function reads a text file and adds each word to the trie.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Function suggest_words
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>List <span style=color:#a6e22e>suggest_words</span>(Trie<span style=color:#f92672>*</span> trie, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> prefix)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    List liste_mots;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>initializeList</span>(<span style=color:#f92672>&amp;</span>liste_mots);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Trienode<span style=color:#f92672>*</span> current <span style=color:#f92672>=</span> trie<span style=color:#f92672>-&gt;</span>root;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> prefix_copy[<span style=color:#a6e22e>strlen</span>(prefix)];
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strcpy</span>(prefix_copy, prefix);
</span></span><span style=display:flex><span>    prefix_copy[<span style=color:#a6e22e>strlen</span>(prefix) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;\0&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> ((<span style=color:#f92672>*</span>prefix) <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\0&#39;</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>prefix <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>; 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((<span style=color:#f92672>*</span>prefix) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>97</span> <span style=color:#f92672>||</span> (<span style=color:#f92672>*</span>prefix) <span style=color:#f92672>&gt;</span>  <span style=color:#ae81ff>122</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            index <span style=color:#f92672>=</span> <span style=color:#ae81ff>27</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (current<span style=color:#f92672>-&gt;</span>child[index] <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Le préfixe n&#39;existe pas dans le dictionnaire.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> liste_mots;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>child[index];  
</span></span><span style=display:flex><span>        prefix<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>100</span>];
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>search_prefix</span>(current, prefix_copy, buffer, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>liste_mots);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>triFusion</span>(<span style=color:#f92672>&amp;</span>liste_mots);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> liste_mots;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The suggest_words function is central to the program. It takes a prefix and a trie tree containing words as inputs. It searches for all words in the dictionary that start with this prefix by traversing the trie tree from the root to the last node corresponding to the prefix&rsquo;s last letter. Then, it uses a search function to find all words following this prefix and stores them in a linked list, which it sorts before returning.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Functions for saving/loading trie
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>serialize_trie</span>(Trienode <span style=color:#f92672>*</span>root, FILE <span style=color:#f92672>*</span>file);
</span></span><span style=display:flex><span>Trienode<span style=color:#f92672>*</span> <span style=color:#a6e22e>deserialize_trie</span>(FILE <span style=color:#f92672>*</span>file);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>save_trie</span>(Trie <span style=color:#f92672>*</span>trie);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>load_trie</span>(Trie <span style=color:#f92672>*</span>trie);
</span></span></code></pre></div><p>These functions allow saving and loading the trie structure from a binary file.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In conclusion, the predictive typing software developed in C is a powerful tool that can predict the next word based on the frequency of words in a text file. The software uses a hash table to store the words and their frequency and a trie data structure to predict the next word based on the user&rsquo;s input. The software is efficient and can predict the next word in real time.</p><p>However, today these types of software are not used anymore because of the power of modern computers and the use of machine learning.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.noe.backert.fr/tags/c/>C</a></li><li><a href=https://www.noe.backert.fr/tags/programming/>Programming</a></li></ul><nav class=paginav><a class=prev href=https://www.noe.backert.fr/projects/isa/><span class=title>« Prev</span><br><span>Solidarity engineer project</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.noe.backert.fr/>Noé Backert | Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>